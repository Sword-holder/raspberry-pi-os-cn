# 谈谈Raspberry Pi OS项目以及如何高效地学习操作系统？
几年前，我开始看Linux内核的源码。当时，我认为自己是一个经验丰富的软件开发者，我看得懂汇编语言和C语言，并且对操作系统领域的概念也了如指掌，比如进程调度、虚拟内存管理等。然而，第一次挑战看源码时，我彻彻底底地失败了,我发现自己一无所知。  
  
我在尝试阅读其它软件项目的源码时，有一种屡试不爽的简单方法：首先我找到整个程序的入口，然后跟着程序流程走，对于我感兴趣的函数，我会跳入函数内部，了解它的细节。这种方法非常有效，但在操作系统这样精细的软件面前，似乎行不通。刚接触操作系统时，我花了超过一周的时间去找到程序的入口，其中最的严重问题在于当我面对短短几行代码的时候，我完全不知道它是用来做什么的。这种情况对于汇编语言来说是挺常见的，但即使是在c语言的部分中，仍然有不少类似的情况。  
  
我绝不是那种在开始遇到一些复杂的问题，就选择放弃的人。而且，我相信世界上没有复杂的问题，一切看似复杂的问题，实际上都是取多简单问题的叠加。因此，我尝试寻找一种高效的方式去学习操作系统的开发，尤其是Linux。  
  
# 学习操作系统时面临的挑战
我知道现在讲Linux内核的书籍、文档可以说是汗牛充栋，但没有一本是我理想中的读物。其中一半的阅读材料都太过于浅显，里面的内容都是我早已熟知的，而另一半有个共同问题，就是当书本越讲越深的时候，90%的细节实际上跟内核的概念无关，而是与一些安全、效率、硬件以及许许多多的系统特性相关，这样的话，你就会陷入到种种繁琐而无关紧要的细节中去，无法清晰地认识到内核中真正核心的东西。  
  
在学习之前，你可能会问为什么我们需要学习操作系统的开发？对我来说，最主要的理由还是我对程序在底层工作的机理非常感兴趣，这不仅仅是一种兴趣，而是你做的工作越精深，你就越容易发现，很多问题归根结底都在于操作系统层面。如果你不了解系统底层是如何工作的，你对自己写的程序就无法达到完全理解的程度。另一个原因就是，如果你非常喜欢在技术上挑战自我的话，那么操作系统绝对是一个能让你感到兴奋的工作。  
  
你可能会问的下一个问题是，为什么我偏偏要看Linux呢？其它的操作系统或许入门会更简单一些。回答是我希望我的知识能在未来的工作中用到，所以Linux是绝佳的研究对象，现如今从小小的物联网设备，到大的服务器，都是用了Linux系统。  
  
当我说大多数关于Linux的读物都不适合我的时候，我承认我说谎了。确实有一本书通过讲解真实的源代码，来介绍必要的操作系统基础概念，即使在我对操作系统一无所知的时候，我都能完完全全地读懂它，这本书书名叫做《Linux Device Drivers》，也难怪它是介绍Linux内核书籍最有名的书籍之一。它先介绍了源码中一些简单的驱动程序，你能够自己编译、捣鼓它们。之后，它开始逐一介绍如何用一些新的概念，去修改内核驱动的源代码。这就是我之前所说的“理想中的读物”。这本书唯一的问题在于它专注于驱动的开发，但对于内核的实现却少有提及。  
  
但为什么没人为内核开发者去写一本简单的读物呢？我认为这是因为，如果你的书是基于当前版本的Linux内核写的，那是不可能写得简单的。当前版本的Linux中，没有一个函数、结构、模块简单到能够作为你的切入点。而且一时间你也不能把新的东西加入到现有的代码中，因为内核代码之间的耦合是非常紧密的。当我认识到这一点后，我萌生出一个想法：如果对于学习操作系统开发的人而言，Linux内核是那么庞大而且复杂的话，为什么不开发一个自己的操作系统，专门用于操作系统的学习呢？因此，我自己制作了一个简单的操作系统，企图通过这个它让读者获得更好的学习体验。同时，如果这个操作系统差不多是仿照Linux做的，多数代码都是对Linux源码的一种简化，所以这份教程也有助于入门Linux。除了这个操作系统，我还决定为它教程写一系列的教程，教程将提供操作系统主要概念的阐述和对于源代码的深入解读。  
  
# 这个操作系统的基本要求
我开始做这个RPi OS项目的时候，做的第一件事就是决定哪些是内核的核心部分，哪些可以认为是次要的（作为初学者可以跳过的），我认为每一个操作系统有两个基本目标：  
  
1.独立地运行用户的进程  
2.使每个用户进程在使用机器资源的时候，有一个统一的、平等的视角  
  
为了满足第一个要求，RPi OS需要有一个专门的进程调度算法。如果我想要实现一个调度算法，我必须先实现对时钟中断的处理，因为一般来说操作系统都会引入分时调度的机制。要实现第二个要求意味着操作系统应该要支持外部驱动程序，并且要实现系统调用接口，并将其暴露给应用程序。由于这个教程是给初学者看的，我不希望初学者接触过多复杂的硬件，因此该系统唯一的驱动就是就是通过键盘向屏幕中输入字符。同时，这个操作系统需要能够加载并执行应用程序，自然地它就需要能够解读可执行文件的格式。如果操作系统能够支持网络的话就再好不过了，但我不希望初学者在这方面投入太多精力。这些就是我认为了操作系统的核心概念了。  
  
现在，让我们来看看我希望忽略的东西：  
1.**性能** ：我不希望为了提高系统的效率，去刻意用一些非常复杂的算法。而且我打算禁用所有的缓存和其它一些优化技术，这些都是为了尽可能地简化系统。  
2.**安全** ：RPi OS有最基本的安全保障：虚拟内存机制，其它的安全技术可以暂时忽略。  
3.**多进程与同步机制** ：我的操作系统能够执行单个进程，我已经非常开心了，如果考虑多进程的，将会多很多庞大而繁琐的工作，尤其是在进程同步方面。  
4.**多种体系结构与设备上的兼容性** ：这个将会在下一节提到  
5.**商业化操作系统中成千上万的特性**  
  
# 为什么选树莓派？
我之前已经提到过我不希望RPi OS支持多种体系结构的兼容性，我在深入阅读了很多Linux驱动源码后，强烈感觉到即使是功能相同的设备，在不同的芯片上，实现方式也差了很多。这个使得驱动的代码很难抽象出来，以提高可复用程度。对我而言，这是内核代码让难懂的原因之一，我当然很想让RPi OS避免这些问题，但我该选什么设备呢？我肯定不想拿我工作的笔记本来做，我连它能否正常工作都不确定，更关键的是，我不想让读者仅仅为了跟读我的教程，而去买昂贵的笔记本电脑（事实上我觉得也不会有这样的人）。也许模拟器是一种看似不错的选择，但我想让它工作在一个实实在在的设备上，那样我才能感觉到我是在跟一个真实的事物打交道而不是跟一个电脑模拟程序。  
最后我选择了树莓派，具体地说是树莓派3B，选择它有很多好处：  
  
1.它只要大概300块钱，我认为多数人还是可以承担地起的。  
2.树莓派是专门为学习设计的，它的内部结构非常简单，完美地符合我的要求。  
3.树莓派使用的是ARM v8架构，这是一个精简指令集架构，适合操作系统开发。它不会有太多的坑，不像x86系列。如果你不信我，你可以对比一下Linux源码中/arch/arm64和/arch/x86文件夹，看看差别。  
  
要注意的是，这个操作系统与树莓派的更早版本并不兼容，因为之前的树莓派并不支持64位和ARM v8架构。  
  
### 上一章节
[主页](https://github.com/Sword-holder/raspberry-pi-os-cn)
### 下一章节
[准备工作](Prerequisites.md)