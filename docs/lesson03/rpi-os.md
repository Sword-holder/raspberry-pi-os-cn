## 3.1：中断

从第一节课中，我们已经明白了如何与硬件进行交流。然而，大多是情况下，交流的模式并不是那么简单。通常，这种模式是异步的：我们向某个设备发送一些命令，但设备并不会立马作出回应，而是在它完成工作后再来提醒我们。这样的异步消息被称为“中断”，因为他们打断了正常的执行流程，并且强行让处理器去执行一个“中断处理程序”。

有这样一个设备是专门用在操作系统开发上：系统计时器。我们能够给它指定一个固定的时间，让它以这个固定频率去打断处理器。计时器可以被用于实现进程调度。一个调度器需要测量每一个进程已经被执行了多久，并利用这个信息去选择下一个要运行的进程，这里就是利用计时器中断来度量运行时间。

### 中断 vs 异常

在ARM.v8架构下，中断是一种特殊的异常。异常可以分为4种类型。

* **同步异常** 这种异常通常是由当前执行的指令引发的。比如，你可以使用`str`指令来把一些数据存储到不存在内存地址上，这样就会产生一个同步异常。同步异常也可以被用于生成一个“软中断”。软中断是一种用`svc`指令来生成的一种同步异常。在第五章，我们会使用这个技术来实现系统调用。

* **IRQ（中断请求）** 这些是常规的中断。他们通常是异步的，这意味着它们跟当前执行指令没有任何关联。与同步异常不同，它们通常不是由处理器本身产生的，而是由外部硬件产生的。

* **FIQ（快速中断请求）**这种类型的异常被称为“快速中断”，它仅仅是为了实现优先级异常而存在，优先级异常机制允许我们将一些中断配置为“常规”，另一些配置为“快速”。快速中断将被优先响应，并且会被一个独立的异常处理程序处理。Linux没有用快速中断，我们也不打算使用这个。

* **SError（系统错误）** 就像`IRQ`和`FIQ`一样，`SError`异常是异步的，由外部硬件引发。与`IRQ`和`FIQ`不同的是，`SError`通常意味着出现了一些错误。[这里](https://community.arm.com/processors/f/discussions/3205/re-what-is-serror-detailed-explanation-is-required)你能找到一些例子来解释`SError`发生的情况。


### 异常向量

每一种异常都需要自己的处理程序。同时，应该为中断发生时的不同运行状态定义不同的处理程序。从异常处理的角度来看，由四种运行状态是非常有意思的，如果程序运行在EL1这些状态可以被定义为：

1. **EL1t** 异常是在当栈指针与EL0共享时在EL1被捕获到。这种情况在`SPSel`寄存器被设为`0`的时候发生。
1. **EL1h** 异常是在栈指针由EL1专用的情况下在EL1被捕获到的。这意味着`SPSel`被置为`1`，这是我们目前使用的模式。
1. **EL0_64** 异常在64位模式下在EL0被捕获。
1. **EL0_32** 异常在32位模式下在EL0被捕获。


总的来说，我们需要定义16个异常处理程序（4个异常等级乘以4种运行状态）。一种保存所有异常处理程序入口地址的特殊结构叫做*异常向量表*或*向量表*。一个向量表的结构被定义在[AArch64参考手册](https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile)的1876中的`Table D1-7 Vector offsets from vector table base address`。你可以认为一个向量表就是一系列的异常向量，这里的异常向量（或处理程序）是一系列负责处理异常特定异常的指令序列。相应地，从`Table D1-7`到`AArch64参考手册`，每一个异常向量最多占用`0x80`字节。这个占用量并不多，但是没人能阻止我们从一个异常向量中跳转到其它内存位置。

我认为用一个例子能把这些都解释清楚，现在就让我们来看看异常向量是如何在RPi-OS中被实现的。一切与异常处理相关的程序都被定义在[entry.S](../src/lesson03/src/entry.S)，我们现在来一探究竟。

第一个有用的宏被称为[ventry](../src/lesson03/src/entry.S#L12)，它被用来创建向量表的入口。

```
    .macro    ventry    label
    .align    7
    b    \label
    .endm
```

正如你能从这个定义中推断出的，我们不打算在异常向量中处理异常，而是跳转到一个名为`label`的宏中再做处理。我们需要使用`.align 7`指令，因为所有的异常向量应该被一个接一个地以`0x80`为偏移量的位置。

向量表被定义在[这里](../src/lesson03/src/entry.S#L64)，它包含了16个`ventry`的定义。现在，我们只关心处理`EL1h`下的`IRQ`，但我们仍然需要把全部16个处理程序定义出来。这不是一些硬件的要求，而是因为我们希望在出错的时候，看到一个有意义的错误信息。所有以`invalid`为后缀的处理程序都不应该在正常的程序流程中运行，使用[handle_invalid_entry](../src/lesson03/src/entry.S#L3)宏可以实现这一点，让我们一起看一下这个宏是如何实现的：

```
    .macro handle_invalid_entry type
    kernel_entry
    mov    x0, #\type
    mrs    x1, esr_el1
    mrs    x2, elr_el1
    bl    show_invalid_entry_message
    b    err_hang
    .endm
```

在第一行，你可以看到另一个宏：`kernel_entry`。我们简要讨论一下它。然后我们调用[show_invalid_entry_message](../src/lesson03/include/entry.h#L6)，然后为这个函数准备了三个参数。第一参数是[这里](../src/lesson03/include/entry.h#L6)的三种异常类型，它确切地告诉我们哪一个处理程序会被执行。第二个参数是最重要的，它被称为`ESR`，代表了异常综合表征寄存器，这个参数是从`esr_el1`中获取的，在`AAech64参考手册`的2431页有对它的描述。这个寄存器包含了异常被引发的详细信息。第三个参数对于同步异常来说是最重要的，它的值是从我们熟悉的`elr_el1`寄存器中取出来的，包含了异常产生时被执行指令的地址。对于同步异常，这指的就是引发异常的指令。
`show_invalid_entry_message`函数向屏幕打印了所有信息，之后我们让处理程序进入无限循环，因为我们要做的事情已经完成了。

### 保存寄存器状态

在异常处理程序结束后，我们希望所有的寄存器恢复到异常发生前的值。如果我们不实现这种功能，一个中断就能影响到与之无关的当前执行程序的行为，这种影响是无法预测的。这就是为什么当异常产生后，我们要做的第一件事就是保存处理器状态。这部分被实现在[kernel_entry](../src/lesson03/src/entry.S)宏中，这个宏非常简单，它仅仅将`x0 - x30`保存至栈中。还有一个对应的宏，叫[kernel_exit](../src/lesson03/src/entry.S#L37)，它将在异常处理程序结束后被调用，它也会执行`eret`指令将程序返回正常的执行流。顺带一提，在执行异常处理程序之前，通用寄存器不止是需要唯一需要被保存的东西，但对于简单的内核来说已经足够了。在之后的课程中，我们将给`kernel_entry`和`kernel_exit`添加更多的功能。

### 设置向量表

好，我们现在准备好了向量表，但处理器并不知道向量表的位置，因此还没法使用它。为了让异常处理程序运作起来，我们必须将`vbal_el1`（向量基地址寄存器）设置为向量表的地址。这部分是现在[这里](../src/lesson03/src/irq.S#L2)。

```
.globl irq_vector_init
irq_vector_init:
    adr    x0, vectors        // load VBAR_EL1 with virtual
    msr    vbar_el1, x0        // vector table address
    ret
```

### 屏蔽/启用中断

另一件需要知道事情就是，就是启用所有的中断。让我来解释一下我说的“启用”是什么意思。有时候，在执行一段特定的代码时，我们需要使其无法被异步中断打断。想象一下，在执行`kernel_entry`时，如果一个中断发生了，会出现什么情况？这种情况下，处理器状态会因覆盖而丢失。这就是为什么当异常处理程序在执行时，处理器会自动地屏蔽所有类型的中断，即所谓的“屏蔽”，在必要的时候我们也可以手动实现这一操作。

很多人误认为在整个异常处理过程中，都应该屏蔽中断。这是不对的，在我们保存了处理器状态后，就可以打开中断，这也意味着中断可以嵌套。我们不准备现在立马做这个，但这是一个应该被记住的重要信息。

屏蔽和启用中断由[这两个函数](../src/lesson03/src/irq.S#L7-L15)负责。


```
.globl enable_irq
enable_irq:
    msr    daifclr, #2
    ret

.globl disable_irq
disable_irq:
    msr    daifset, #2
        ret
```

ARM处理器中，有4个比特是负责记录不同类型中断的屏蔽状态的，这些比特按如下方式定义。

* **D** 屏蔽调试异常。这是一种特殊的同步异常。显然，我们不可能屏蔽所有同步异常，但可以很方便地用一个单独的标识符来标记调试异常的屏蔽。
* **A** 屏蔽`SErrors`。它被称为`A`，因为`SErrors`又是被称为异步终止。
* **I** 屏蔽`IRQs`
* **F** 屏蔽`FIQs`

现在你也许可以猜到负责改变中断屏蔽状态的寄存器叫做`daifclr`和`daifset`了，这些寄存器做的事情就是设置和清空处理器状态。

最后一件你可能会感到疑惑的事情就是，为什么我们在两个函数中都使用常量`2`？这是因为我们只希望设置和清空第二个(`I`)比特。

### 配置中断控制器

设备通常不会直接打断处理器的运行，而是会以来中断控制器来完成这项工作。中断控制器可以被用于启用/禁用硬件发送的中断请求。我们可以用中断控制器获取到发出中断的设备。树莓派有它自己的中断控制器，[BCM2837 ARM外部设备手册](https://github.com/raspberrypi/documentation/files/1888662/BCM2837-ARM-Peripherals.-.Revised.-.V2-1.pdf)中的109页对此做出了描述。

树莓派的中断控制器中，有3个寄存器是记录所有中断类型的启用/禁用情况的。现在，我们只对时钟中断有兴趣，它可以通过[ENABLE_IRQS_1](../src/lesson03/include/peripherals/irq.h#L10)寄存器来启用，在`BCM2837 ARM外部设备手册`中的116页有相关描述。根据文档，中断分为2个存储区。第一个存储区包含了`0 - 31`号中断，每一个中断都能通过设置`ENABLE_IRQS_1`的相应位来控制启用或禁止。最后面的32个中断也有相应的寄存器来控制——`ENABLE_IRQS_2`，另外还有一个叫`ENABLE_BASIC_IRQS`的寄存器控制了一些公共的中断和ARM的本地中断（我们会在之后的章节中谈到ARM本地中断）。然而，这份外部设备手册有很多错误，其中一个跟我们讨论的内容有直接联系。外部设备中断表（在手册的113页）的`0 - 3`行包含了4个系统时钟中断。根据Linux的逆向工程得到的源码，阅读[这一部分](http://embedded-xinu.readthedocs.io/en/latest/arm/rpi/BCM2835-System-Timer.html)可以得知时钟中断0和2是保留的，被GPU使用，中断1和3可以被用于其它用途。因此这里有个[函数](../src/lesson03/src/irq.c#L29)启用了1号系统计时器的IRQ。

```
void enable_interrupt_controller()
{
    put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
}
```

### 通用IRQ处理程序

从之前的讨论中，你应该记住了我们单独有一个用于处理所有`IRQ`的异常处理程序。这个处理程序定义在[这里](../src/lesson03/src/irq.c#L39)

```
void handle_irq(void)
{
    unsigned int irq = get32(IRQ_PENDING_1);
    switch (irq) {
        case (SYSTEM_TIMER_IRQ_1):
            handle_timer_irq();
            break;
        default:
            printf("Unknown pending irq: %x\r\n", irq);
    }
}
```

在处理程序中，我们需要辨别异常是由哪一个设备引发的。中断控制器可以帮助我们完成这个工作：它有记录`0 - 31`号异常状态的`IRQ_PENDING_1`寄存器。利用这个寄存器，我们可以检查当前中断是由计时器产生的，还是由其它设备产生的，如果是其它设备产生的我们就调用特定的设备中断处理程序。注意，同一时刻可能有多个中断请求处于等待状态。这就是为什么每一个特定的设备中断处理程序在完成处理后都需要应答的原因，只有应答后，它在`IRQ_PENDING_1`上的对应位才会被清除。处于这个原因，对于一个成熟的操作系统，你应该希望编写一个循环，其内部是switch结构，这样你才能够在一个处理程序上处理多种不同的中断。

### 计时器初始化

树莓派系统计时器是一个非常简单的设备。它由一个计数器，每一下滴答，计数器的值就加1。同样有4条中断控制线连接到中断控制器（因此能产生四个不同的中断）和4个对应的比较寄存器。当计数器的值变为等于存储在比较寄存器之一中的值时，将触发相应的中断。这就是为什么我们在使用系统时钟中断之前，先要将比较寄存器初始化为一个非零值，这个值越大，中断就会被越晚触发。这部分实现在[timer_init](../src/lesson03/src/timer.c#L8)函数中。

```
const unsigned int interval = 200000;
unsigned int curVal = 0;

void timer_init ( void )
{
    curVal = get32(TIMER_CLO);
    curVal += interval;
    put32(TIMER_C1, curVal);
}
```

第一行读取当前计数器的值，第二行对这个值加一，然后第三行将比较寄存器的值设为中断号1。通过操纵`interval`的值，你可以调整第一个时钟中断产生的时间。

### 处理计数器中断

最后，我们来到了时钟中断处理器程序。事实上它非常简单。

```
void handle_timer_irq( void )
{
    curVal += interval;
    put32(TIMER_C1, curVal);
    put32(TIMER_CS, TIMER_CS_M1);
    printf("Timer interrupt received\n\r");
}
```

这里我们线更新了比较寄存器的值，这样下一个中断将会在同样的时间后被触发。接着，我们将`TIMER_CS`写为1来作为中断的响应。在文档中，`TIMER_CS`被称为“计时器控制/状态”寄存器，该寄存器的[0:3]位可以被用于响应来自4条可用中断线的中断。

### 结论

你可能最后还想看看[kernel_main](../src/lesson03/src/kernel.c#L7)函数，它负责协调所有先前讨论的功能。之后你编译运行这个样例，在时钟中断发生后，就能在屏幕上看到“Timer interrupt received”字样。请自己动手做一下，不要忘了仔细检查代码并不断进行实验。

#### 之前的章节
2.2 [Processor initialization: Exercises](../../docs/lesson02/rpi-os.md)

##### Next Page

3.2 [Interrupt handling: Low-level exception handling in Linux](../../docs/lesson03/linux/low_level-exception_handling.md)

